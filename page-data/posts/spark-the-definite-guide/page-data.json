{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/spark-the-definite-guide/","result":{"data":{"site":{"siteMetadata":{"author":{"name":"Yunitto"},"disqusShortname":"https-yunitto-github-io","subtitle":"","title":"Yunitto's blog","url":"https://yunitto.github.io"}},"markdownRemark":{"id":"3e305161-d616-51e8-86a8-bda0f865c475","html":"<p>한빛 미디어의 <a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=14300380\">&#x3C;스파크 완벽 가이드: 스파크를 확용한 빅데이터 처리와 분석의 모든 것></a>을 공부하며 정리한 내용입니다.</p>\n<hr>\n<h4 id=\"spark-application은-driver-process와-executor-process-로-구성\"><a href=\"#spark-application%EC%9D%80-driver-process%EC%99%80-executor-process-%EB%A1%9C-%EA%B5%AC%EC%84%B1\" aria-label=\"spark application은 driver process와 executor process 로 구성 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spark Application은 <strong>driver process</strong>와 <strong>executor process</strong> 로 구성.</h4>\n<ul>\n<li>\n<p>driver process</p>\n<ul>\n<li><code class=\"language-text\">main()</code> 함수 실행</li>\n<li>Application 정보 관리, exceutor process 관리</li>\n</ul>\n</li>\n<li>\n<p>executor process</p>\n<ul>\n<li>driver가 할당한 코드 실행, 다시 보고. </li>\n</ul>\n</li>\n<li>JVM 위의 SparkSession 객체가 진입점이 된다.</li>\n<li>Spark API 는 크게 두가지 - structured, unstructured</li>\n<li>하나의 SparkSession은 하나의 SparkApplication에 대응한다. 즉, 앱 하나당 하나의 드라이버 프로세스가 존재.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// def range(end: Long): org.apache.spark.sql.Dataset[Long]</span>\n<span class=\"token comment\">// def toDF(colNames: String*): DataFrame</span>\n<span class=\"token keyword\">val</span> spark <span class=\"token operator\">=</span> SparkSession<span class=\"token punctuation\">.</span>builder<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>getOrCreate<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> myRange <span class=\"token operator\">=</span> spark<span class=\"token punctuation\">.</span>range<span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>toDF<span class=\"token punctuation\">(</span><span class=\"token string\">\"Number\"</span><span class=\"token punctuation\">)</span> </code></pre></div>\n<p>클러스터 모드의 경우, 숫자의 범위가 나뉘어서 서로 다른 여러 익스큐터에 할당된다.</p>\n<hr>\n<h3 id=\"dataframe\"><a href=\"#dataframe\" aria-label=\"dataframe permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dataframe</h3>\n<ul>\n<li>Structured API</li>\n<li>데이터를 테이블 형식(Row,Column)으로 표시</li>\n<li>Row 단위로 분산</li>\n</ul>\n<h3 id=\"partition\"><a href=\"#partition\" aria-label=\"partition permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Partition</h3>\n<ul>\n<li>데이터의 분할 단위 == 클러스터의 물리적 머신에 존재하는 Row의 집합 </li>\n<li>Dataframe의 파티션은 실행 중에 데이터가 물리적으로 분산되는 방식</li>\n<li>병렬성은 파티션 수와 익스큐터 수에 의해 결정.</li>\n</ul>\n<h2 id=\"spark-operations-transformation-and-action\"><a href=\"#spark-operations-transformation-and-action\" aria-label=\"spark operations transformation and action permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spark Operations: Transformation and Action</h2>\n<h3 id=\"1-transformation\"><a href=\"#1-transformation\" aria-label=\"1 transformation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Transformation</h3>\n<ul>\n<li>\n<p>데이터가 immutable 하기 때문에 변경 방법을 계획해두는 것.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// def where(conditionExpr: String): Dataset[Row]</span>\nscala<span class=\"token operator\">></span> myRange<span class=\"token punctuation\">.</span>where<span class=\"token punctuation\">(</span><span class=\"token string\">\"number % 2 == 0\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// DF에서 짝수만 찾기</span>\nres0<span class=\"token operator\">:</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>spark<span class=\"token punctuation\">.</span>sql<span class=\"token punctuation\">.</span>Dataset<span class=\"token punctuation\">[</span>org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>spark<span class=\"token punctuation\">.</span>sql<span class=\"token punctuation\">.</span>Row<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>number<span class=\"token operator\">:</span> bigint<span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n<li>Transformation은 추상적인 변경방법이기 때문에 바로 결과가 나오지 않고, Action을 통해 실행해야한다.</li>\n</ul>\n<h4 id=\"dependency-narrow-vs-wide\"><a href=\"#dependency-narrow-vs-wide\" aria-label=\"dependency narrow vs wide permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dependency: Narrow vs. Wide</h4>\n<ul>\n<li>\n<p>Narrow Dependency: 1개의 인풋 파티션 1 -> 1개의 아웃풋 파티션</p>\n<ul>\n<li><code class=\"language-text\">where</code> : 각 인풋 파티션에서 where()을 하여 아웃풋 파티션이 됨.</li>\n<li><strong>메모리</strong>에서만 실행. 파이프라이닝 수행.</li>\n</ul>\n</li>\n<li>\n<p>Wide Dependency: 1개의 인풋 파티션 -> n개의 아웃풋 파티션</p>\n<ul>\n<li><code class=\"language-text\">shuffle</code>: 각 인풋 파티션의 데이터가 여러 아웃풋 파티션으로 분산됨.</li>\n<li>셔플의 결과를 <strong>디스크</strong>에 저장.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"lazy-evaluation지연-연산\"><a href=\"#lazy-evaluation%EC%A7%80%EC%97%B0-%EC%97%B0%EC%82%B0\" aria-label=\"lazy evaluation지연 연산 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lazy Evaluation(지연 연산)</h4>\n<ul>\n<li>Transformation의 실행 계획 생성, 마지막 순간에 컴파일 —> <strong>전체 데이터 흐름 최적화</strong></li>\n</ul>\n<h4 id=\"predicate-pushdown\"><a href=\"#predicate-pushdown\" aria-label=\"predicate pushdown permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Predicate Pushdown</h4>\n<ul>\n<li>Predicate: boolean(True or False)을 리턴하는 쿼리 조건. SQL의 경우 WHERE clause.</li>\n<li>필터링을 데이터베이스로 위임하는 쿼리 최적화 기법. 데이터베이스 레벨에서 필터링을 하여 가져오는 레코드 수를 줄이면 처리비용과 시간을 최소화하여 쿼리 성능을 향상시킨다.</li>\n<li>더 볼것. <a href=\"https://docs.datastax.com/en/dse/6.0/dse-dev/datastax_enterprise/spark/sparkPredicatePushdown.html\">https://docs.datastax.com/en/dse/6.0/dse-dev/datastax_enterprise/spark/sparkPredicatePushdown.html</a></li>\n</ul>\n<h3 id=\"2-action\"><a href=\"#2-action\" aria-label=\"2 action permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Action</h3>\n<ul>\n<li>Transformation이 논리적 실행 계획이라면 Action은 실제 계산을 수행.</li>\n<li>\n<p>Action을 지정하면 <strong>스파크 잡</strong>이 시작된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\">scala<span class=\"token operator\">></span> res0<span class=\"token punctuation\">.</span>count\nres1<span class=\"token operator\">:</span> <span class=\"token builtin\">Long</span> <span class=\"token operator\">=</span> <span class=\"token number\">50</span></code></pre></div>\n</li>\n</ul>","fields":{"slug":"/posts/spark-the-definite-guide/","tagSlugs":["/tag/spark/","/tag/scala/"]},"frontmatter":{"date":"2019-05-23","description":"<스파크 완벽 가이드: 스파크를 확용한 빅데이터 처리와 분석의 모든 것>","tags":["spark","scala"],"title":"스파크 완벽 가이드"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/spark-the-definite-guide/"}}}